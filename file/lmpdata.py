#!/usr/bin/env python3
# pylmpdata.py  
# LAMMPS data file handler by Ruixing Wang

import os
class LammpsDataFile(object):
    def __init__(self, filename):
        self.abspath = os.path.abspath(filename)
        self.nBonds = 0
        self.nAngles = 0
        self.nDihedrals = 0
        self.nImpropers = 0
        self.optstrs = {
            "Velocities":"Velocities",
            "Bonds": "Bonds",
            "Angles": "Angles",
            "Dihedrals": "Dihedrals",
            "Impropers": "Impropers",
            "NonBondCoeffs": "NonBond Coeffs",
            "PairCoeffs": "Pair Coeffs",
            "BondCoeffs": "Bond Coeffs",
            "AngleCoeffs": "Angle Coeffs",
            "DihedralCoeffs": "Dihedral Coeffs",
            "ImproperCoeffs": "Improper Coeffs",
            "BondBondCoeffs": "BondBond Coeffs",
            "BondAngleCoeffs": "BondAngle Coeffs",
            "AngleAngleCoeffs": "AngleAngle Coeffs",
            "AngleAngleTorsionCoeffs": "AngleAngleTorsion Coeffs",
            "EndBondTorsionCoeffs": "EndBondTorsion Coeffs",
            "MiddleBondTorsionCoeffs": "MiddleBondTorsion Coeffs",
            "BondBond13Coeffs": "BondBond13 Coeffs",
            "AngleTorsionCoeffs": "AngleTorsion Coeffs"
        }

    def read(self):
        self.f = open(self.abspath, 'r')
        f = self.f
        next(f)
        def strToNumber(string):
            if string.isdigit():
                return int(string)
            else:
                return float(string)

        for line in f:
            line = line.split("#")[0]
            #Headers
            if line.find('atoms') > 0:
                self.nAtoms = int(line.split()[0])
            if line.find('bonds') > 0:
                self.nBonds = int(line.split()[0])
            if line.find('angles') > 0:
                self.nAngles = int(line.split()[0])
            if line.find('dihedrals') > 0:
                self.nDihedrals = int(line.split()[0])
            if line.find('impropers') > 0:
                self.nImpropers = int(line.split()[0])
            if line.find('atom types') > 0:
                self.nAtomTypes = int(line.split()[0])
            if line.find('bond types') > 0:
                self.nBondTypes = int(line.split()[0])
            if line.find('angle types') > 0:
                self.nAngleTypes = int(line.split()[0])
            if line.find('dihedral types') > 0:
                self.nDihedralTypes = int(line.split()[0])
            if line.find('improper types') > 0:
                self.nImproperTypes = int(line.split()[0])
            if line.find('xlo') > 0:
                split = line.split()
                self.xlo = float(split[0])
                self.xhi = float(split[1])
            if line.find('ylo') > 0:
                split = line.split()
                self.ylo = float(split[0])
                self.yhi = float(split[1])
            if line.find('zlo') > 0:
                split = line.split()
                self.zlo = float(split[0])
                self.zhi = float(split[1])

            # readMasses
            if line.find("Masses") == 0:
                next(f)
                self.Masses = []
                for i in range(0, self.nAtomTypes):
                    split = next(f).split()
                    self.Masses.append(float(split[1]))
            # readAtoms
            if line.find("Atoms") == 0:
                next(f)
                self.tags = []
                self.atomtypes = []
                self.atomcharges = []
                self.coordinates = []
                self.nxnynz = []
                for i in range(0, self.nAtoms):
                    numbers = next(f).split()
                    self.tags.append(int(numbers[1]))
                    self.atomtypes.append(int(numbers[2]))
                    self.atomcharges.append(float(numbers[3]))
                    self.coordinates.append(list(map(float, numbers[4:7])))
                    self.nxnynz.append(list(map(int, numbers[7:10])))
            # readOptionals
            for key, value in self.optstrs.items():
                if line.find(value) == 0:
                    f = self.f
                    next(f)
                    setattr(self, key, [])
                    for line in f:
                        if not line.strip():
                            break
                        line = line.split("#")[0]
                        coeffs = line.split()[1:]
                        getattr(self, key).append(list(map(strToNumber, coeffs)))
        f.close()

        return


    def write(self, filename):
        f = open(filename, 'w')
        # Headers
        st = 'LAMMPS data file generated by pylmpdata.py. / Ruixing Wang\n\n'
        st += '\t{} atoms\n'.format(self.nAtoms)
        st += '\t{} bonds\n'.format(self.nBonds)
        st += '\t{} angles\n'.format(self.nAngles)
        st += '\t{} dihedrals\n'.format(self.nDihedrals)
        st += '\t{} impropers\n'.format(self.nImpropers)
        st += '\n'
        st += '\t{} atom types\n'.format(self.nAtomTypes)
        if self.nBonds != 0:
            st += '\t{} bond types\n'.format(self.nBondTypes)
        if self.nAngles != 0:
            st += '\t{} angle types\n'.format(self.nAngleTypes)
        if self.nDihedrals != 0:
            st += '\t{} dihedral types\n'.format(self.nDihedralTypes)
        if self.nImpropers != 0:
            st += '\t{} improper types\n'.format(self.nImproperTypes)
        st += '\n'
        st += '\t{: .9f}\t{: .9f} xlo xhi\n'.format(self.xlo, self.xhi)
        st += '\t{: .9f}\t{: .9f} ylo yhi\n'.format(self.ylo, self.yhi)
        st += '\t{: .9f}\t{: .9f} zlo zhi\n'.format(self.zlo, self.zhi)
        st += '\n'
        f.write(st)

        # Masses
        st = 'Masses\n\n'
        for i, item in enumerate(self.Masses):
            st += '\t{}  {:.6f}\n'.format(i + 1, item)
        st += '\n'
        f.write(st)

        # Atoms
        st = 'Atoms\n\n'
        for i in range(0, self.nAtoms):
            st += "{}  {}  {}  {}  {}  {}\n".format(
                i + 1, self.tags[i], self.atomtypes[i], self.atomcharges[i],
                '  '.join(map(str, self.coordinates[i])), '  '.join(
                    map(str, self.nxnynz[i])))
        st += '\n'
        f.write(st)

        # Optionals
        for key, value in self.optstrs.items():
            if hasattr(self, key):
                st = value + '\n\n'
                for i, item in enumerate(getattr(self, key)):
                    st += '\t {}  '.format(i + 1) + '   '.join(map(
                        str, item)) + '\n'
                st += '\n'
                f.write(st)

        f.close()

        return
